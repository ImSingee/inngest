package tracing

import (
	"encoding/json"

	"github.com/inngest/inngest/pkg/enums"
	"github.com/inngest/inngest/pkg/execution/queue"
	"github.com/inngest/inngest/pkg/execution/state"
	statev2 "github.com/inngest/inngest/pkg/execution/state/v2"
	"github.com/inngest/inngest/pkg/tracing/meta"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/trace"
)

// DropSpan marks the span to be dropped.
func DropSpan(span trace.Span) {
	span.SetAttributes(attribute.Bool(meta.AttributeDropSpan, true))
	span.End()
}

// ApplyResponseToSpan applies details from the given `DriverResponse` to the
// given span. This is used for adding additional details to the span after the
// exectution has completed.
func WithDriverResponseAttrs(resp *state.DriverResponse) trace.SpanStartEventOption {
	attrs := []attribute.KeyValue{}

	if resp.IsDiscoveryResponse() {
		// We ignore discovery responses and rely on other spans to show steps
		// generated by handling opcodes later on.
		attrs = append(attrs, attribute.Bool(meta.AttributeDropSpan, true))
		return trace.WithAttributes(attrs...)
	}

	headerByt, _ := json.Marshal(resp.Header)
	attrs = append(attrs,
		attribute.String(meta.AttributeResponseHeaders, string(headerByt)),
		attribute.Int(meta.AttributeResponseStatusCode, resp.StatusCode),
		attribute.Int(meta.AttributeResponseOutputSize, resp.OutputSize),
	)

	return trace.WithAttributes(attrs...)
}

func WithGeneratorAttrs(op *state.GeneratorOpcode) trace.SpanStartEventOption {
	// Generic attributes for all steps
	attrs := []attribute.KeyValue{
		attribute.String(meta.AttributeStepID, op.ID),
		attribute.String(meta.AttributeStepOp, op.Op.String()),
		attribute.String(meta.AttributeStepName, op.UserDefinedName()),
	}

	switch op.Op {
	case enums.OpcodeAIGateway:
		{
			// TODO
		}

	case enums.OpcodeGateway:
		{
			// TODO
		}

	case enums.OpcodeInvokeFunction:
		{
			if opts, err := op.InvokeFunctionOpts(); err == nil {
				attrs = append(attrs,
					// attribute.Int64(AttributeStepInvokeExpiry, opts.),
					attribute.String(meta.AttributeStepInvokeFunctionID, opts.FunctionID),
					attribute.String(meta.AttributeStepInvokeTriggerEventID, opts.Payload.ID),
				)

				if expiry, err := opts.Expires(); err == nil {
					attrs = append(attrs,
						attribute.Int64(meta.AttributeStepInvokeExpiry, expiry.UnixMilli()),
					)
				}
			}
		}

	case enums.OpcodeSleep:
		{
			if dur, err := op.SleepDuration(); err == nil {
				attrs = append(attrs,
					attribute.Int64(meta.AttributeStepSleepDuration, int64(dur)),
				)
			}
		}

	case enums.OpcodeStep, enums.OpcodeStepRun:
		{

		}

	case enums.OpcodeStepError:
		{

		}

	case enums.OpcodeStepPlanned:
		{

		}

	case enums.OpcodeWaitForEvent:
		{
			if opts, err := op.WaitForEventOpts(); err == nil {
				attrs = append(attrs,
					attribute.String(meta.AttributeStepWaitForEventName, opts.Event),
				)

				if expiry, err := opts.Expires(); err == nil {
					attrs = append(attrs,
						attribute.Int64(meta.AttributeStepWaitForEventExpiry, expiry.UnixMilli()),
					)
				}

				if opts.If != nil && *opts.If != "" {
					attrs = append(attrs,
						attribute.String(meta.AttributeStepWaitForEventIf, *opts.If),
					)
				}
			}
		}
	}

	return trace.WithAttributes(attrs...)
}

func SpanFromQueueItem(i *queue.Item) *meta.SpanMetadata {
	if i == nil || i.Metadata == nil {
		return nil
	}

	if carrier, ok := i.Metadata["wobbly"]; ok {
		var out meta.SpanMetadata
		if err := json.Unmarshal([]byte(carrier), &out); err == nil {
			return &out
		}
	}

	return nil
}

func RunSpanFromMetadata(md *statev2.Metadata) *meta.SpanMetadata {
	if md == nil {
		return nil
	}

	return md.Config.NewFunctionTrace()
}
