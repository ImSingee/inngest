package tracing

import (
	"context"
	"encoding/json"

	"github.com/davecgh/go-spew/spew"
	"github.com/inngest/inngest/pkg/enums"
	"github.com/inngest/inngest/pkg/execution"
	"github.com/inngest/inngest/pkg/execution/queue"
	"github.com/inngest/inngest/pkg/execution/state"
	statev2 "github.com/inngest/inngest/pkg/execution/state/v2"
	"github.com/inngest/inngest/pkg/inngest"
	"github.com/inngest/inngest/pkg/tracing/meta"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/propagation"
	"go.opentelemetry.io/otel/trace"
)

// DropSpan marks the span to be dropped.
func DropSpan(span trace.Span) {
	span.SetAttributes(attribute.Bool(meta.AttributeDropSpan, true))
	span.End()
}

func WithFunctionAttrs(f *inngest.Function) trace.SpanStartEventOption {
	url, err := f.URI()
	if err != nil {
		spew.Dump(err)
		return nil
	}

	return trace.WithAttributes(
		attribute.String(meta.AttributeRequestURL, url.String()),
	)
}

func WithResumeAttrs(r *execution.ResumeRequest) trace.SpanStartEventOption {
	attrs := []attribute.KeyValue{}

	// TODO

	return trace.WithAttributes(attrs...)
}

// ApplyResponseToSpan applies details from the given `DriverResponse` to the
// given span. This is used for adding additional details to the span after the
// exectution has completed.
func WithDriverResponseAttrs(resp *state.DriverResponse) trace.SpanStartEventOption {
	attrs := []attribute.KeyValue{}

	if resp.IsDiscoveryResponse() {
		// We ignore discovery responses and rely on other spans to show steps
		// generated by handling opcodes later on.
		attrs = append(attrs, attribute.Bool(meta.AttributeDropSpan, true))
		// return trace.WithAttributes(attrs...)
	}

	headerByt, _ := json.Marshal(resp.Header)
	attrs = append(attrs,
		attribute.String(meta.AttributeResponseHeaders, string(headerByt)),
		attribute.Int(meta.AttributeResponseStatusCode, resp.StatusCode),
		attribute.Int(meta.AttributeResponseOutputSize, resp.OutputSize),
	)

	return trace.WithAttributes(attrs...)
}

func WithGeneratorAttrs(op *state.GeneratorOpcode) trace.SpanStartEventOption {
	// Generic attributes for all steps
	attrs := []attribute.KeyValue{
		attribute.String(meta.AttributeStepID, op.ID),
		attribute.String(meta.AttributeStepOp, op.Op.String()),
		attribute.String(meta.AttributeStepName, op.UserDefinedName()),
	}

	// Try get stack line
	if stack, err := op.StackLine(); err == nil && stack != nil && *stack != "" {
		attrs = append(attrs,
			attribute.String(meta.AttributeCodeLocation, *stack),
		)
	}

	switch op.Op {
	case enums.OpcodeAIGateway:
		{
			// TODO
		}

	case enums.OpcodeGateway:
		{
			// TODO
		}

	case enums.OpcodeInvokeFunction:
		{
			if opts, err := op.InvokeFunctionOpts(); err == nil {
				attrs = append(attrs,
					// attribute.Int64(AttributeStepInvokeExpiry, opts.),
					attribute.String(meta.AttributeStepInvokeFunctionID, opts.FunctionID),
					attribute.String(meta.AttributeStepInvokeTriggerEventID, opts.Payload.ID),
				)

				if expiry, err := opts.Expires(); err == nil {
					attrs = append(attrs,
						attribute.Int64(meta.AttributeStepInvokeExpiry, expiry.UnixMilli()),
					)
				}
			}
		}

	case enums.OpcodeSleep:
		{
			if dur, err := op.SleepDuration(); err == nil {
				attrs = append(attrs,
					attribute.Int64(meta.AttributeStepSleepDuration, int64(dur)),
				)
			}
		}

	case enums.OpcodeStep, enums.OpcodeStepRun:
		{

		}

	case enums.OpcodeStepError:
		{

		}

	case enums.OpcodeStepPlanned:
		{

		}

	case enums.OpcodeWaitForEvent:
		{
			if opts, err := op.WaitForEventOpts(); err == nil {
				attrs = append(attrs,
					attribute.String(meta.AttributeStepWaitForEventName, opts.Event),
				)

				if expiry, err := opts.Expires(); err == nil {
					attrs = append(attrs,
						attribute.Int64(meta.AttributeStepWaitForEventExpiry, expiry.UnixMilli()),
					)
				}

				if opts.If != nil && *opts.If != "" {
					attrs = append(attrs,
						attribute.String(meta.AttributeStepWaitForEventIf, *opts.If),
					)
				}
			}
		}
	}

	return trace.WithAttributes(attrs...)
}

func SpanFromQueueItem(i *queue.Item) *meta.SpanMetadata {
	spew.Dump("tracing.SpanFromQueueItem")
	if i == nil || i.Metadata == nil {
		spew.Dump("tracing.SpanFromQueueItem", "no metadata")
		return nil
	}

	if carrier, ok := i.Metadata[meta.PropagationKey]; ok {
		spew.Dump("tracing.SpanFromQueueItem", "found carrier", carrier)
		var out meta.SpanMetadata
		if err := json.Unmarshal([]byte(carrier.(string)), &out); err == nil {
			return &out
		}

		spew.Dump("tracing.SpanFromQueueItem", "error unmarshalling carrier")
	}

	spew.Dump("tracing.SpanFromQueueItem", "no carrier")

	return nil
}

func SpanFromPause(p *state.Pause) *meta.SpanMetadata {
	spew.Dump("tracing.SpanFromPause")
	if p == nil || p.Metadata == nil {
		spew.Dump("tracing.SpanFromPause", "no metadata")
		return nil
	}

	if carrier, ok := p.Metadata[meta.PropagationKey]; ok {
		spew.Dump("tracing.SpanFromPause", "found carrier", carrier)
		var out meta.SpanMetadata
		if err := json.Unmarshal([]byte(carrier.(string)), &out); err == nil {
			return &out
		}

		spew.Dump("tracing.SpanFromPause", "error unmarshalling carrier")
	}

	spew.Dump("tracing.SpanFromPause", "no carrier")

	return nil
}

// TODO Everywhere this is used, we're creating a step span directly under the
// run. When supporting userland spans anywhere, this method must be deprecated
// and all calls should instead use something that fetches which span (run or
// _userland_) this step should be under.
//
// A single exception is maybe the very first execution, but also with that we
// shoud have the run span inside the queue item's metadata.
func RunSpanFromMetadata(md *statev2.Metadata) *meta.SpanMetadata {
	if md == nil {
		return nil
	}

	return md.Config.NewFunctionTrace()
}

func spanContextFromMetadata(m *meta.SpanMetadata) trace.SpanContext {
	if m == nil {
		return trace.SpanContext{}
	}

	carrier := propagation.MapCarrier{
		"traceparent": m.TraceParent,
		"tracestate":  m.TraceState,
	}

	ctx := propagation.TraceContext{}.Extract(context.Background(), carrier)
	sc := trace.SpanContextFromContext(ctx)

	return sc
}
